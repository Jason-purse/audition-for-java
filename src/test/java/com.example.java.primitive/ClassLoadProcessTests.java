package com.example.java.primitive;

import org.junit.jupiter.api.Test;

import java.util.Objects;

/**
 * @author FLJ
 * @date 2023/2/15
 * @time 9:27
 * @Description 类加载过程处理
 *
 * 加载,验证,准备,解析，初始化
 * 其中,验证,准备,解析统称为连接 ..
 * 加载：通过一个类的全限定名来获取定义此类的二进制字节流，在内存中生成一个代表这个类的java.lang.Class对象。
 * 验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
 * 准备：为静态变量分配内存并设置静态变量初始值，这里所说的初始值“通常情况”下是数据类型的零值。(例如 int类型的值,默认为0..)
 * 解析：将常量池内的符号引用替换为直接引用。(这个过程一般对于我们来说,不是很重要) ..
 * 初始化：到了初始化阶段，才真正开始执行类中定义的 Java 初始化程序代码。主要是静态变量赋值动作和静态语句块（static{}）中的语句。
 *
 */
public class ClassLoadProcessTests {

    static  {
        System.out.println("静态代码块");
    }

    static String value = Objects.requireNonNullElseGet(null,() -> {
        System.out.println("执行");
        return "123";
    });

    public static void main(String[] args) {
        System.out.println("main");
    }

    /**
     * gc 过程处理 ..
     * 在触发GC的时候,目前我已知的两种 young gc 和 full gc ..
     *
     * 触发young gc是由于新生代的eden区没有足够的空间分配时才会触发 young gc ...
     * 触发full gc:
     *  - 当准备触发young gc的时候,如果发现统计数据说之前的young gc的平均晋升大小比老年代剩余的空间大,那么则不会触发young gc 而是转为触发 full gc ...f
     *  - 如果有永久代,在永久代需要分配空间而没有足够空间时,触发 full gc ..
     *  - system.gc() 默认触发full gc ..
     *  - heap dump 默认也是 full gc ..
     *  - cms gc 出现 concurrent mode failure 会导致一次 full gc 产生 ..
     *
     *  对jvm 认为已经死掉的对象,即从 gc root 开始搜索,搜索不到的并且经过一次筛选标记为没有复活的对象..
     *
     *  对这些已经死掉的对象进行垃圾收集,新生代使用复制算法,老年代使用标记-清除和标记-整理算法 ..
     *
     *  gc root有那些:
     *      - 虚拟机栈(栈帧中的本地变量表)中引用的对象 ..
     *      - 方法区中类静态属性引用的对象
     *      - 方法区常量引用的对象
     *      - 本地(native )方法栈中 jni(native方法)引用的对象 ..
     *
     *  垃圾收集有哪些算法,特点是:
     *  1. 标记-清除算法
     *      标记所有需要回收的对象,标记完成之后统一回收.. 但是它有不足,效率问题 - 标记和清除过程效率不高,另一个是空间问题,标记清除之后会产生大量的内存碎片 ..
     *      空间碎片太多可能导致程序在后续分配较大内存时无法找到足够的连续内存而有一次触发垃圾回收动作 ..
     *  2. 复制算法
     *      解决效率问题 ,通过copying搜集算法出现,将内存按容量大小相等的两块,每次只使用其中一块,当一块内存用完了,将活着的对象复制到另一个内存块上，然后将
     *      使用过的内存空间进行清理掉,这样每次对半个区进行内存回收,内存分配时也就不需要考虑内存碎片的复杂情况,只需要移动堆顶指针按照顺序分配内存即可 .. 实现简单且运行高效 ..
     *      代价就是内存缩小为原来的一半,牺牲了空间 ..
     *  3. 标记-整理算法
     *      复制收集算法在对象存活率较高的时候就进行较多的复制操作,效率将变低,更关键的是不想浪费50%的空间,这就需要有额外的空间分配担保,以应对被使用的内存中所有的对象100%存活的极端情况,
     *      所有老年代一般不能直接使用这种算法 ..
     *      那么根据老年代的特点,提出了标记-整理(mark-compact)_算法,标记过程和"标记-清除算法一样",但是后续步骤不是直接堆可回收对象进行清理,而是让所有存活的对象都向一段移动,然后清理掉
     *      (端边界以外)的内存 ..
     *
     *  4.分代收集算法
     *      当前商业虚拟机的垃圾收集采用"分代收集(generational collection)算法),这个算法没有新的思想,指示根据对象的存活周期的不同将内存划分为几块 ..
     *      一般把java堆分为新生代和老年代,这样可以根据各个年代的特点采用最合适的收集算法 ..
     *      在新生代中,每次垃圾回收时如果发现有大量的对象死亡,只有少量存活,就使用复制算法,那么只需要付出少量存活对象的复制成本就可以完成收集 ..
     *      在老年代中,因为对象存活效率高,没有额外的空间对它进行分配担保,就必须使用标记-清理或者标记-整理算法进行回收 ..
     */
    @Test
    public void gcProcessTests() {

    }
}
